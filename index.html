<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hex Twist ¬∑ Kreisel-Sturm</title>
    <style>
        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            font-family: 'Segoe UI', Roboto, system-ui, sans-serif;
            margin: 0;
            padding: 0;
        }
        body {
            background: radial-gradient(circle at 50% 30%, #1e2f3f, #0b1219);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }
        .game-container {
            max-width: 600px;
            width: 100%;
            background: rgba(10, 20, 30, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 50px;
            padding: 20px 15px 25px;
            box-shadow: 0 30px 40px rgba(0,0,0,0.6), 0 0 0 2px #3f5566 inset;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 0 10px;
        }
        .score-panel {
            background: #1e2e3c;
            border-radius: 40px;
            padding: 10px 25px;
            box-shadow: inset 0 -4px 0 #0c141c, 0 8px 0 #0a1117;
            color: #ffd966;
            font-weight: bold;
            font-size: 1.8rem;
            letter-spacing: 1px;
            text-shadow: 0 3px 0 #8b6f2c;
        }
        .highscore-panel {
            background: #1e2e3c;
            border-radius: 40px;
            padding: 10px 20px;
            box-shadow: inset 0 -4px 0 #0c141c, 0 8px 0 #0a1117;
            color: #a0c4ff;
            font-weight: bold;
            font-size: 1.2rem;
            text-shadow: 0 2px 0 #2a4b7c;
        }
        .energy-bar-container {
            background: #15232e;
            border-radius: 30px;
            height: 30px;
            margin: 10px 15px 20px;
            box-shadow: inset 0 4px 6px rgba(0,0,0,0.8);
            overflow: hidden;
            border: 2px solid #2e4a5a;
        }
        .energy-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #55ff55, #2ecc71);
            border-radius: 30px;
            transition: width 0.2s ease;
            box-shadow: 0 0 15px #00ff88;
        }
        .canvas-wrapper {
            display: flex;
            justify-content: center;
            margin: 10px 0;
            background: #0d1a24;
            border-radius: 60px;
            padding: 15px;
            box-shadow: inset 0 0 0 3px #2a4050, 0 20px 30px -5px black;
        }
        canvas {
            width: 100%;
            aspect-ratio: 1/1;
            display: block;
            background: #17232e;
            border-radius: 40px;
            touch-action: none;  /* Verhindert Scrollen */
            box-shadow: 0 0 0 4px #3b5568;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 25px 0 15px;
            flex-wrap: wrap;
        }
        .rotate-btn {
            background: #4a6fa5;
            border: none;
            color: white;
            font-size: 2rem;
            font-weight: bold;
            padding: 15px 35px;
            border-radius: 60px;
            box-shadow: 0 12px 0 #1f3a5f, 0 10px 20px black;
            transition: all 0.08s linear;
            text-transform: uppercase;
            letter-spacing: 2px;
            touch-action: manipulation;
            cursor: pointer;
            min-width: 150px;
        }
        .rotate-btn:active {
            transform: translateY(8px);
            box-shadow: 0 4px 0 #1f3a5f;
        }
        .rotate-btn:disabled {
            opacity: 0.4;
            transform: translateY(4px);
            box-shadow: 0 6px 0 #1f3a5f;
            pointer-events: none;
        }
        .newgame-btn {
            background: #8e44ad;
            box-shadow: 0 12px 0 #5e2b7a;
            padding: 15px 40px;
            font-size: 1.5rem;
        }
        .info-text {
            text-align: center;
            color: #9bb7d4;
            font-size: 1rem;
            font-weight: 500;
            text-shadow: 0 2px 2px black;
            margin-top: 15px;
        }
        .gameover-message {
            text-align: center;
            font-size: 2rem;
            font-weight: 800;
            color: #ffaaaa;
            text-shadow: 0 5px 0 #8b0000;
            letter-spacing: 3px;
            display: none;
        }
        .gameover-message.show {
            display: block;
        }
    </style>
</head>
<body>
<div class="game-container">
    <div class="header">
        <div class="highscore-panel" id="highscoreDisplay">üèÜ 0</div>
        <div class="score-panel" id="scoreDisplay">üí∞ 0</div>
    </div>

    <div class="energy-bar-container">
        <div class="energy-fill" id="energyFill" style="width: 100%;"></div>
    </div>

    <div class="canvas-wrapper">
        <canvas id="gameCanvas" width="600" height="600"></canvas>
    </div>

    <div class="controls">
        <button class="rotate-btn" id="rotateLeftBtn" aria-label="Links drehen">‚Ü∫ LINKS</button>
        <button class="rotate-btn" id="rotateRightBtn" aria-label="Rechts drehen">‚Üª RECHTS</button>
    </div>
    <div style="display: flex; justify-content: center;">
        <button class="rotate-btn newgame-btn" id="newGameBtn">üîÑ NEUES SPIEL</button>
    </div>
    <div class="gameover-message" id="gameoverMessage">‚ö° GAME OVER ‚ö°</div>
    <div class="info-text">
        Tippe ein Hex an (gelber Rand) ‚Üí dann mit Links/Rechts drehen
    </div>
</div>

<script>
    (function() {
        // -------------------- SPIELKONFIGURATION --------------------
        const GRID_RADIUS = 3;               // Hexagon-Radius: ergibt 1 + 3*radius*(radius+1) Zellen, hier 37
        const COLORS = [
            '#FF5252', // hellrot
            '#5CD65C', // hellgr√ºn
            '#5C9EFF', // hellblau
            '#FFB84D', // orange
            '#D94FFF', // lila
            '#FFDB5C'  // gelb
        ];
        const BASE_POINTS = 10;               // Punkte pro gel√∂schte Zelle
        const ROTATE_ENERGY_COST = 5;          // Energiekosten pro Drehung
        const ENERGY_REGEN_PER_SEC = 2;         // Regeneration pro Sekunde
        const MAX_ENERGY = 100;

        // -------------------- GLOBALE VARIABLEN --------------------
        let grid = new Map();                   // Key "q,r" -> Farbindex (0..5)
        let selectedHex = null;                 // { q, r } des aktuell gew√§hlten Zentrums
        let currentScore = 0;
        let highScore = 0;
        let energy = MAX_ENERGY;
        let gameOver = false;
        let processing = false;                  // Verhindert Mehrfachaktionen w√§hrend Animation/Drehung
        let animationFrame = null;
        let matchAnimation = { active: false, cells: [], startTime: 0 };

        // DOM-Elemente
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const highscoreDisplay = document.getElementById('highscoreDisplay');
        const energyFill = document.getElementById('energyFill');
        const gameoverMessage = document.getElementById('gameoverMessage');
        const rotateLeftBtn = document.getElementById('rotateLeftBtn');
        const rotateRightBtn = document.getElementById('rotateRightBtn');
        const newGameBtn = document.getElementById('newGameBtn');

        // Hilfsvariablen f√ºr Touch (sp√§ter f√ºr Direktauswahl)
        let touchStart = null;

        // -------------------- INITIALISIERUNG --------------------
        function initGrid() {
            grid.clear();
            // Erzeuge alle Zellen innerhalb eines hexagonalen Bereichs mit Radius GRID_RADIUS
            for (let q = -GRID_RADIUS; q <= GRID_RADIUS; q++) {
                for (let r = -GRID_RADIUS; r <= GRID_RADIUS; r++) {
                    if (Math.abs(q + r) <= GRID_RADIUS) {  // Bedingung f√ºr hexagonale Form
                        const color = Math.floor(Math.random() * COLORS.length);
                        grid.set(`${q},${r}`, color);
                    }
                }
            }
            selectedHex = null;  // Auswahl zur√ºcksetzen
        }

        // Highscore laden/speichern
        function loadHighScore() {
            const saved = localStorage.getItem('hexTwist_highscore');
            if (saved) highScore = parseInt(saved, 10) || 0;
        }
        function saveHighScore() {
            if (currentScore > highScore) {
                highScore = currentScore;
                localStorage.setItem('hexTwist_highscore', highScore);
            }
        }
        function updateUI() {
            scoreDisplay.innerText = `üí∞ ${currentScore}`;
            highscoreDisplay.innerText = `üèÜ ${highScore}`;
            energyFill.style.width = `${Math.max(0, (energy / MAX_ENERGY) * 100)}%`;
            if (energy <= 0) energyFill.style.width = '0%';
        }

        // -------------------- HEX-KOORDINATEN-UMRECHNUNG --------------------
        function hexToPixel(q, r) {
            // axial to pixel (pointy-top)
            const size = canvas.width / (2 * GRID_RADIUS * 1.8);  // Skalierung
            const x = size * (Math.sqrt(3) * q + Math.sqrt(3)/2 * r);
            const y = size * (3/2 * r);
            // Zentrierung
            const xOffset = canvas.width / 2;
            const yOffset = canvas.height / 2;
            return { x: x + xOffset, y: y + yOffset };
        }

        function pixelToHex(px, py) {
            // Umkehrung: finde ungef√§hre (q,r)
            const size = canvas.width / (2 * GRID_RADIUS * 1.8);
            const x0 = px - canvas.width/2;
            const y0 = py - canvas.height/2;
            // Nach Formeln
            const q = (x0 * (2/3) / size - y0 * (1/3) / size) / Math.sqrt(3) * 2; // etwas tricky
            const r = y0 * (2/3) / size;
            // Runde auf n√§chsten Integer im Hex-Gitter
            return axialRound(q, r);
        }

        function axialRound(q, r) {
            // Rundet floating-point zu axialen Koordinaten (gen√§hert)
            let s = -q - r;
            let rq = Math.round(q);
            let rr = Math.round(r);
            let rs = Math.round(s);
            const qDiff = Math.abs(rq - q);
            const rDiff = Math.abs(rr - r);
            const sDiff = Math.abs(rs - s);
            if (qDiff > rDiff && qDiff > sDiff) {
                rq = -rr - rs;
            } else if (rDiff > sDiff) {
                rr = -rq - rs;
            }
            return { q: rq, r: rr };
        }

        // -------------------- NACHBARN UND GRUPPEN --------------------
        function getNeighbors(q, r) {
            // 6 Nachbarn in axialen Koordinaten
            return [
                { q: q+1, r: r   },
                { q: q+1, r: r-1 },
                { q: q,   r: r-1 },
                { q: q-1, r: r   },
                { q: q-1, r: r+1 },
                { q: q,   r: r+1 }
            ];
        }

        // Pr√ºft, ob eine Zelle im Grid existiert
        function hasCell(q, r) {
            return grid.has(`${q},${r}`);
        }

        // -------------------- DREHEN DES KREISELS (7 Zellen) --------------------
        function rotateAround(centerQ, centerR, clockwise) {
            if (!hasCell(centerQ, centerR)) return false; // Zentrum muss existieren

            // Sammle die 7 Zellen: Zentrum + 6 Nachbarn (falls vorhanden)
            const cells = [{ q: centerQ, r: centerR }];
            const neighbors = getNeighbors(centerQ, centerR);
            for (let n of neighbors) {
                if (hasCell(n.q, n.r)) cells.push(n);
            }
            if (cells.length < 3) return false; // Mindestens Zentrum + zwei Nachbarn, aber eigentlich immer 7 im vollen Feld

            // Extrahiere Farben in der Reihenfolge im Uhrzeigersinn ab einem Startnachbarn
            // Reihenfolge der Nachbarn (im Uhrzeigersinn): wir nehmen die getNeighbors-Reihenfolge als Referenz
            // Diese ist bereits im Uhrzeigersinn (f√ºr pointy-top axial):
            // (1,0), (1,-1), (0,-1), (-1,0), (-1,1), (0,1)
            // Aber wir brauchen eine konsistente Reihenfolge f√ºr Rotation.
            // Wir bauen ein Array mit den existierenden Nachbarn in fester Reihenfolge.
            const neighborOrder = getNeighbors(centerQ, centerR);
            const existingNeighbors = neighborOrder.filter(n => hasCell(n.q, n.r));
            const colors = existingNeighbors.map(n => grid.get(`${n.q},${n.r}`));

            if (clockwise) {
                // Rotiere nach rechts: letztes Element wird erstes
                colors.unshift(colors.pop());
            } else {
                // Rotiere nach links: erstes Element wird letztes
                colors.push(colors.shift());
            }

            // Setze die neuen Farben
            existingNeighbors.forEach((n, idx) => {
                grid.set(`${n.q},${n.r}`, colors[idx]);
            });
            // Zentrum bleibt unver√§ndert? Nein, wir wollen, dass das Zentrum auch rotiert? Normalerweise rotieren alle 7.
            // In unserer Implementierung rotieren nur die Nachbarn um das Zentrum, das Zentrum selbst bleibt gleich.
            // Das ist okay ‚Äì es entspricht einem Kreisel, bei dem das Zentrum fest ist.
            return true;
        }

        // -------------------- MATCH-ERKENNUNG (Linien in 3 Richtungen) --------------------
        function getLineMatches() {
            const matches = new Set(); // Set von "q,r"-Strings
            const directions = [
                { dq: 1, dr: 0 },  // horizontal (q-Richtung)
                { dq: 1, dr: -1 }, // diagonal /
                { dq: 0, dr: 1 }   // diagonal \
            ];

            for (let [key, color] of grid.entries()) {
                const [q, r] = key.split(',').map(Number);
                for (let dir of directions) {
                    const line = [];
                    // Gehe in positive Richtung
                    for (let i = 0; i < 5; i++) { // maximal 5 L√§nge
                        const nq = q + i * dir.dq;
                        const nr = r + i * dir.dr;
                        const nKey = `${nq},${nr}`;
                        if (grid.get(nKey) === color) line.push(nKey);
                        else break;
                    }
                    // Gehe in negative Richtung (ohne Startpunkt doppelt)
                    for (let i = 1; i < 5; i++) {
                        const nq = q - i * dir.dq;
                        const nr = r - i * dir.dr;
                        const nKey = `${nq},${nr}`;
                        if (grid.get(nKey) === color) line.unshift(nKey);
                        else break;
                    }
                    if (line.length >= 3) {
                        line.forEach(cell => matches.add(cell));
                    }
                }
            }
            return Array.from(matches);
        }

        // Entfernt gematchte Zellen (setzt sie auf -1 als Platzhalter) und gibt Anzahl zur√ºck
        function removeMatches(matchList) {
            let count = 0;
            for (let key of matchList) {
                if (grid.has(key)) {
                    grid.set(key, -1); // Markierung "leer"
                    count++;
                }
            }
            return count;
        }

        // F√ºllt leere Zellen (-1) mit neuen Zufallsfarben
        function refillEmpty() {
            for (let [key, value] of grid.entries()) {
                if (value === -1) {
                    grid.set(key, Math.floor(Math.random() * COLORS.length));
                }
            }
        }

        // -------------------- SPIELZUG MIT MATCH-ANIMATION --------------------
        function processMove(clockwise) {
            if (gameOver || processing || !selectedHex) return;
            if (energy < ROTATE_ENERGY_COST) {
                alert("Nicht genug Energie!");
                return;
            }

            processing = true;
            disableButtons(true);

            // Energie abziehen
            energy -= ROTATE_ENERGY_COST;
            if (energy < 0) energy = 0;
            updateUI();

            // 1. Drehung ausf√ºhren
            rotateAround(selectedHex.q, selectedHex.r, clockwise);

            // 2. Zeichne das Grid sofort (ohne Animation)
            drawGrid();

            // 3. Starte die Match-√úberpr√ºfung mit kleiner Verz√∂gerung (f√ºr Gef√ºhl)
            setTimeout(() => {
                resolveMatchesAfterMove();
            }, 150);
        }

        function resolveMatchesAfterMove() {
            // Wiederhole Matches, bis keine mehr vorhanden
            function step() {
                const matches = getLineMatches();
                if (matches.length === 0) {
                    // Keine Matches mehr: Zug beendet
                    finishMove();
                    return;
                }

                // Punkte f√ºr Matches
                const points = matches.length * BASE_POINTS;
                currentScore += points;
                saveHighScore();
                updateUI();

                // Animation der matches starten
                animateMatches(matches, () => {
                    // Nach Animationsende: Zellen entfernen und neu f√ºllen
                    removeMatches(matches);
                    refillEmpty();
                    drawGrid();

                    // N√§chster Schritt (weitere Matches durch Nachfall?)
                    // Da wir sofort neu f√ºllen, k√∂nnen neue Matches entstanden sein. Deshalb wiederhole step.
                    setTimeout(step, 200); // kurze Pause f√ºrs Auge
                });
            }

            step();
        }

        function animateMatches(matchKeys, callback) {
            // Einfache Animation: Hebe die Zellen f√ºr 150 ms hell hervor
            matchAnimation = { active: true, cells: matchKeys, startTime: performance.now() };
            drawGrid(); // zeichnet mit Highlight

            setTimeout(() => {
                matchAnimation.active = false;
                drawGrid(); // normal zeichnen
                callback();
            }, 200);
        }

        function finishMove() {
            processing = false;
            disableButtons(false);
            // Pr√ºfe auf Game Over (Energie alle oder keine Z√ºge mehr m√∂glich? Wir lassen Energie entscheiden)
            if (energy <= 0) {
                gameOver = true;
                gameoverMessage.classList.add('show');
                disableButtons(true);
            }
            drawGrid();
        }

        // -------------------- ENERGIE-REGENERATION --------------------
        setInterval(() => {
            if (gameOver) return;
            if (energy < MAX_ENERGY) {
                energy = Math.min(MAX_ENERGY, energy + ENERGY_REGEN_PER_SEC);
                updateUI();
            }
        }, 1000);

        // -------------------- ZEICHNEN --------------------
        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const size = canvas.width / (2 * GRID_RADIUS * 1.8);
            for (let [key, colorIdx] of grid.entries()) {
                if (colorIdx === -1) continue; // leere Zellen werden nicht gezeichnet (sollten nicht vorkommen)
                const [q, r] = key.split(',').map(Number);
                const { x, y } = hexToPixel(q, r);

                // Pr√ºfen, ob Zelle in Match-Animation ist
                const isHighlight = matchAnimation.active && matchAnimation.cells.includes(key);

                drawHexagon(x, y, size * 0.9, COLORS[colorIdx], isHighlight);
            }

            // Markiere ausgew√§hltes Hex (falls vorhanden)
            if (selectedHex && hasCell(selectedHex.q, selectedHex.r)) {
                const { x, y } = hexToPixel(selectedHex.q, selectedHex.r);
                drawHexagonOutline(x, y, size * 0.95, '#FFD966', 5);
            }
        }

        function drawHexagon(x, y, rad, color, highlight) {
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = Math.PI / 6 + i * Math.PI / 3; // pointy-top
                const xOff = rad * Math.cos(angle);
                const yOff = rad * Math.sin(angle);
                if (i === 0) ctx.moveTo(x + xOff, y + yOff);
                else ctx.lineTo(x + xOff, y + yOff);
            }
            ctx.closePath();

            // F√ºllung
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 4;
            ctx.shadowOffsetY = 4;
            ctx.fillStyle = color;
            ctx.fill();

            // Glanzlicht
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 2;
            ctx.stroke();

            if (highlight) {
                ctx.shadowBlur = 20;
                ctx.shadowColor = 'white';
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 5;
                ctx.stroke();
            }
        }

        function drawHexagonOutline(x, y, rad, color, width) {
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = Math.PI / 6 + i * Math.PI / 3;
                const xOff = rad * Math.cos(angle);
                const yOff = rad * Math.sin(angle);
                if (i === 0) ctx.moveTo(x + xOff, y + yOff);
                else ctx.lineTo(x + xOff, y + yOff);
            }
            ctx.closePath();
            ctx.shadowBlur = 15;
            ctx.shadowColor = color;
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.stroke();
            ctx.shadowBlur = 0;
        }

        // -------------------- INTERAKTION (TIPPEN AUFS CANVAS) --------------------
        function handleCanvasTap(clientX, clientY) {
            if (gameOver || processing) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const canvasX = (clientX - rect.left) * scaleX;
            const canvasY = (clientY - rect.top) * scaleY;

            const { q, r } = pixelToHex(canvasX, canvasY);
            if (hasCell(q, r)) {
                selectedHex = { q, r };
                drawGrid();
            }
        }

        // -------------------- BUTTONS --------------------
        function disableButtons(disabled) {
            rotateLeftBtn.disabled = disabled;
            rotateRightBtn.disabled = disabled;
            newGameBtn.disabled = disabled; // newGame soll immer gehen, aber disabled setzen wir trotzdem
        }

        // -------------------- NEUES SPIEL --------------------
        function newGame() {
            gameOver = false;
            gameoverMessage.classList.remove('show');
            processing = false;
            disableButtons(false);
            selectedHex = null;
            currentScore = 0;
            energy = MAX_ENERGY;
            initGrid();
            updateUI();
            drawGrid();
        }

        // -------------------- EVENT LISTENER --------------------
        function setupEvents() {
            // Touch und Maus f√ºr Canvas
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (e.touches.length > 0) {
                    handleCanvasTap(e.touches[0].clientX, e.touches[0].clientY);
                }
            }, { passive: false });

            canvas.addEventListener('mousedown', (e) => {
                e.preventDefault();
                handleCanvasTap(e.clientX, e.clientY);
            });

            // Buttons
            rotateLeftBtn.addEventListener('click', () => {
                processMove(false); // gegen Uhrzeigersinn
            });
            rotateRightBtn.addEventListener('click', () => {
                processMove(true); // im Uhrzeigersinn
            });
            newGameBtn.addEventListener('click', () => {
                newGame();
            });
        }

        // -------------------- START --------------------
        function startGame() {
            loadHighScore();
            initGrid();
            updateUI();
            drawGrid();
            setupEvents();
        }

        window.addEventListener('DOMContentLoaded', startGame);
    })();
</script>
</body>
</html>
